#!/bin/sh
#
# wclock
#
# Copyright (c) 2021 K. Eugene Carlson  Tsukuba, Japan
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
#
# A world clock script for terminal emulator and tty use.
#

unset QUERY
unset city
unset zone
unset SUFFIX
unset SLASHES
unset THERE
unset HERE
unset NOECHO
unset WRITTEN
unset TCPARAMS
unset PARAMSFIXED
unset WARNED
unset ZONEINFO

# Most distributions use /usr/share/zoneinfo, but some don't, e.g. NixOS.
if [ -d "/usr/share/zoneinfo" ]; then
	ZONEINFO=/usr/share/zoneinfo
elif [ -d "/etc/zoneinfo" ]; then
	ZONEINFO=/etc/zoneinfo
# To get compatibility for another zoneinfo location, please don't hesitate to
# raise a GitHub issue!
else
	echo
	echo '	'The zoneinfo directory was not found. Exiting.
	echo
	exit
fi

# Although both posix and right should be available in Linux installations, just
# to be safe.
if [ -d "$ZONEINFO/posix" ]; then
	SUFFIX="posix/"
elif [ -d "$ZONEINFO/right" ]; then
	SUFFIX="right/"
fi

SLASHES="$(echo "$ZONEINFO/$SUFFIX" | tr -cd '/' | wc -c)"
SLASHES=$((SLASHES + 1))

# This method is used to tell "date" about the local time offset when using the
# --local flag.

localcheckval (){
# The local time offset should only be applied once.
[ "$PARAMSFIXED" = "yes" ] && return
if [ "$HERE" = "yes" ]; then
	unset OK
	unset OK2
	unset OVERWRITE
	SPACES="$(echo "$TCPARAMS" | tr -cd ' ' | wc -c)"
	count=0
	# One-argument DATETIME is a special case; just the offset and go
	if [ "$SPACES" != "0" ]; then
		# Testing each argument individually; if the arguments up to
		# that point form a valid "date" string when followed by the
		# local time offset, then the last argument tested is the
		# time of day.
		while [ ! "$count" -gt "$SPACES" ] && [ "$OK" != "yes" ]; do
			cutpoint="$((count +1))"
			tester="$(echo "$TCPARAMS" | cut -d' ' -f"$cutpoint")"
			tester2="$tester$(date +%z)"
			# The actual test.
			date --date="$tester2" > /dev/null 2>&1 && OK=yes || true
			# Mitigating three- and four-digit times without colons
			# not working with time offsets in "date".
			if [ "$OK" != "yes" ]; then
				# Isolating the argument that's being examined.
				[ "$cutpoint" = "1" ] && isolate="$tester"
				[ "$cutpoint" != "1" ] && isolate="$(echo "$tester" | cut -d' ' -f-"$((cutpoint - 1))" | cut -d' ' -f"$cutpoint"-)"
				# The possible three- and four-digit times.
				Y="$(echo "$isolate" | grep -x [0-1][0-9][0-5][0-9])"
				Y2="$(echo "$isolate" | grep -x [0-2][0-3][0-5][0-9])"
				Z="$(echo "$isolate" | grep -x [0-9][0-5][0-9])"
				# Inserting a colon.
				if [ -n "$Y" ] || [ -n "$Y2" ]; then
					isolate="$(echo "$isolate" | cut -c-2)"':'"$(echo "$isolate" | cut -c3-)"
					OVERWRITE=yes
				elif [ -n "$Z" ]; then
					isolate="$(echo "$isolate" | cut -c-1)"':'"$(echo "$isolate" | cut -c2-)"
					OVERWRITE=yes
				fi
				# Replacing the incoming argument for testing.
				if [ "$OVERWRITE" = "yes" ]; then
					[ "$cutpoint" = "1" ] && PARAMTEST="$isolate"\ "$(date +%z)"
					[ "$cutpoint" != "1" ] && PARAMTEST="$(echo "$TCPARAMS" | cut -d' ' -f-"$((cutpoint - 1))")"\ "$isolate"\ "$(date +%z)"
					# Checking for a well-formed "date"
					# string again.
					date --date="$PARAMTEST" > /dev/null 2>&1 && OK2=yes || true
				fi
				# If a well-formed date string was found, alter
				# the actual parameter sequence and exit the
				# loop.
				if [ "$OK2" = "yes" ]; then
					[ "$cutpoint" = "1" ] && TCPARAMS="$isolate"\ "$(echo "$TCPARAMS" | cut -d' ' -f"$((cutpoint + 1))"-)" && OK=yes
					[ "$cutpoint" != "1" ] && TCPARAMS="$(echo "$TCPARAMS" | cut -d' ' -f-"$((cutpoint - 1))")"\ "$isolate"\ "$(echo "$TCPARAMS" | cut -d' ' -f"$((cutpoint + 1))"-)" && OK=yes
				fi
			fi
			count=$((count + 1))
		done
		# Putting the time zone information inside TCPARAMS, based on the
		# test above.
		TCPARAMS="$(echo "$TCPARAMS" | cut -d' ' -f-"$cutpoint")"\ "$(date +%z)"\ "$(echo "$TCPARAMS" | cut -d' ' -f"$((cutpoint + 1))"-)"
	# Single-argument case
	else
		# Although "date" accepts four-digit numbers to represent the
		# time in the --date string, it doesn't work with offsets.
		Y="$(echo "$TCPARAMS" | grep -x [0-1][0-9][0-5][0-9])"
		Y2="$(echo "$TCPARAMS" | grep -x [0-2][0-3][0-5][0-9])"
		Z="$(echo "$TCPARAMS" | grep -x [0-9][0-5][0-9])"
		if [ -n "$Y" ] || [ -n "$Y2" ]; then
			TCPARAMS="$(echo "$TCPARAMS" | cut -c-2)"':'"$(echo "$TCPARAMS" | cut -c3-)"
		elif [ -n "$Z" ]; then
			TCPARAMS="$(echo "$TCPARAMS" | cut -c-1)"':'"$(echo "$TCPARAMS" | cut -c2-)"
		fi
		# comparemethod() will be called later, and it has error
		# checking for bad date strings.
		TCPARAMS="$TCPARAMS"\ "$(date +%z)"
	fi
fi
PARAMSFIXED=yes
}

# The method to use in case of time checks with --local or --there.

comparemethod (){
# --there flag was used.
if [ "$THERE" = "yes" ]; then
	ENTRY="--date=TZ=\""$place"\" $TCPARAMS"
	# Error-checking
	TZ="$place" date "$ENTRY" > /dev/null 2>&1 || { echo '	'The check date for "$headup" appears to have a formatting error. ; return ; }
	echo '	'$(date "$ENTRY" +"%X %Z %x (%a)")'	'Here
	echo '	'"$(TZ="$place" date "$ENTRY" +"%X %Z %x (%a)")"'	'"$headup"
	# Want echoes between different time zones, but not at the end of the
	# script or before the next break flag.
	[ "$X" != "1 $ZONETEMP" ] && echo && NOECHO=yes
fi

# --local flag was used.
if [ "$HERE" = "yes" ]; then
	if [ -h "/etc/localtime" ]; then
		SLASHES2="$(echo "$ZONEINFO/" | tr -cd '/' | wc -c)"
		SLASHES2=$((SLASHES2 + 1))
		HEREZONE="$(readlink /etc/localtime | cut -d'/' -f"$SLASHES2"-)"
	elif [ -f "/etc/timezone" ]; then
		# Debian compatibility.
		HEREZONE="$(cat /etc/timezone)"
	else
		# In case the time zone setting method references neither
		# /etc/localtime nor /etc/timezone.
		SHORTDATE="$(date +"%-z")"
		TRYDATE=GMT"${SHORTDATE%00}"
		if [ -f "$ZONEINFO/"$SUFFIX"Etc/$TRYDATE" ]; then
			HEREZONE=Etc/"$TRYDATE"
		else
			# The above method doesn't work for time zones that
			# have "minutes" in the UTC offset; checking for these
			# here.
			case "$SHORTDATE" in
				-230|-330)
				HEREZONE=America/St_Johns
				;;
				+330)
				# DST is the same as Kabul
				HEREZONE=Asia/Tehran
				;;
				+430)
				HEREZONE=Asia/Kabul
				;;
				+530)
				HEREZONE=Asia/Kolkata
				;;
				+545)
				HEREZONE=Asia/Kathmandu
				;;
				+630)
				# Most-populated
				HEREZONE=Asia/Yangon
				;;
				+845)
				HEREZONE=Australia/Eucla
				;;
				+930)
				HEREZONE=Australia/Darwin
				;;
				+1030)
				# Outside of DST, same as Darwin.
				# Most-populated
				HEREZONE=Australia/Adelaide
				;;				
				+1245|+1345)
				HEREZONE=Pacific/Chatham
				;;
			esac
		fi
	fi
	if [ -n "$HEREZONE" ]; then
		# Etc/* time zones have inverted signs; fix this here if
		# needed.
		unset FIRSTCHARS
		FIRSTCHARS="$(echo "$HEREZONE" | cut -c7 | cut -c2-)"
		case "$FIRSTCHARS" in
			/+)
			HEREZONE="$(echo "$HEREZONE" | tr '+' '-')"
			;;
			/-)
			HEREZONE="$(echo "$HEREZONE" | tr '-' '+')"
			;;
		esac
		ENTRY="--date=TZ=\""$HEREZONE"\" $TCPARAMS"
		# Error-checking
		TZ="$place" date "$ENTRY" > /dev/null 2>&1 || { echo '	'The check date for "$headup" appears to have a formatting error. ; return ; }
		# The local time should only be written out once if there are
		# multiple time zones for comparison.
		[ "$WRITTEN" != "yes" ] && echo '	'"$(date "$ENTRY" +"%X %Z %x (%a)")"'	'Here
		echo '	'$(TZ="$place" date "$ENTRY" +"%X %Z %x (%a)")'	'"$headup"
		WRITTEN=yes
	else
		# An alternative method to be used if the actual local time 
		# zone can't be found. Somewhat unreliable, as seen in the
		# echo statements below.
		ENTRY="--date=TZ=\""$place"\" $TCPARAMS"
		TZ="$place" date "$ENTRY" > /dev/null 2>&1 || { echo '	'The check date for "$headup" appears to have a formatting error. ; return ; }
		[ "$WRITTEN" != "yes" ] && echo '	'"$(date "$ENTRY" +"%X %Z %x (%a)")"'	'Here
		echo '	'$(TZ="$place" date "$ENTRY" +"%X %Z %x (%a)")'	'"$headup"
		WRITTEN=yes
		echo
		echo '	'No local time zone could be found. If the times shown
		echo '	'above fall on different days, the earlier time will
		echo '	'be exactly 24 hours earlier than it should be.
	fi
fi
}

# The main loop for each country/city search argument.

main (){
# "make install" will fill this part in with SHAREDIR. SHAREDIR is PREFIX/share 
# by default.
SHAREDIR=

# For users without a HOME directory, use /tmp instead.
if [ -n "$HOME" ] && [ -d "$HOME" ]; then
	ZONETEMP="$HOME/.zonetemp"
else
	ZONETEMP=/tmp/.zonetemp
fi

# Failsafe: enforcing the use of either a HOME or a writable /tmp directory.
if [ ! -d "$HOME" ] && [ ! -w "/tmp" ]; then
	echo
	echo '	'Neither a home nor a writable /tmp directory was found. 
	echo '	'Please try again with a user account that has a home 
	echo '	'directory or write permissions in /tmp.
	echo
	exit
fi

EXTRAS="$SHAREDIR"/wclock/extras

[ "$QUERY" != "yes" ] && [ -z "$city" ] && echo && echo '	'No search arguments. && wclock --help && exit
# A blank query mode call displays available directories.
[ "$QUERY" = "yes" ] && [ -z "$city" ] && find "$ZONEINFO"/"$SUFFIX" -type d | cut -d'/' -f"$SLASHES"- | less && exit

[ "$NOECHO" != "yes" ] && echo

# If the extras file is missing, just check the directories directly.
[ "$WARNED" != "yes" ] && [ ! -f "$EXTRAS" ] && echo '	'"$EXTRAS" was not found. Only named time zones in && echo '	'"$ZONEINFO"/"$SUFFIX" will be searched. && WARNED=yes && echo

unset TIMESTAMP

if [ -f "$ZONETEMP" ] || [ -d "$ZONETEMP" ] || [ -h "$ZONETEMP" ]; then
	TIMESTAMP="$(date +%s)"
	mv "$ZONETEMP" "$ZONETEMP-$TIMESTAMP"
fi

# If there's an exact match in the extras file, go with that.
unset zone
unset headup
[ -f "$EXTRAS" ] && zone="$(grep -i "^$city	" "$EXTRAS")"
[ -n "$zone" ] && echo "$zone" > "$ZONETEMP"
unset WRITTEN
[ -f "$ZONETEMP" ] && while read -r line; do
	X="$(wc -l "$ZONETEMP")"
	unset name
	unset place
	# "name" is the name of the city; "place" is the time zone.
	name="$(echo "$line" | cut -d'	' -f1)"
	place="$(echo "$line" | cut -d'	' -f2-)"

	# For display purposes.
	if [ ! "$X" = "1 $ZONETEMP" ]; then
		headup="$place"
	else
		headup="$name ($place)"
	fi
	
	# No time check.
	[ -z "$TCPARAMS" ] && echo '	'"$(TZ="$place" date +"%X %Z %x (%a)")"'	'"$name" \("$place"\)
	# Time check.
	[ -n "$TCPARAMS" ] && comparemethod
done < "$ZONETEMP"

# Otherwise, search for a match among the named time zones.
unset zone
[ ! -f "$ZONETEMP" ] && zone="$(find "$ZONEINFO"/"$SUFFIX"* -type f,l | grep -i "$city" | cut -d'/' -f"$SLASHES"-)"

[ -n "$zone" ] && echo "$zone" > "$ZONETEMP"

if [ -n "$zone" ] && [ -f "$ZONETEMP" ]; then
	while read -r place; do
		# For display purposes.
		X="$(wc -l "$ZONETEMP")"
		headup="$place"
	
		[ -z "$TCPARAMS" ] && echo '	'"$(TZ="$place" date +"%X %Z %x (%a)")"'	'"$place"
		[ -n "$TCPARAMS" ] && comparemethod
	done < "$ZONETEMP"
elif [ -z "$zone" ] && [ ! -f "$ZONETEMP" ]; then
	# If no match is available, resort to inexact matches from the extras
	# list.
	unset zones
	[ -f "$EXTRAS" ] && zones="$(grep -i "$city" "$EXTRAS")"
	[ -n "$zones" ] && echo "$zones" >> "$ZONETEMP"
	[ -f "$ZONETEMP" ] && while read -r line; do
		X="$(wc -l "$ZONETEMP")"
		unset name
		unset place
		name="$(echo "$line" | cut -d'	' -f1)"
		place="$(echo "$line" | cut -d'	' -f2-)"
	
		if [ ! "$X" = "1 $ZONETEMP" ]; then
			headup="$place"
		else
			headup="$name ($place)"
		fi
	
		[ -z "$TCPARAMS" ] && echo '	'"$(TZ="$place" date +"%X %Z %x (%a)")"'	'"$name" \("$place"\)
		[ -n "$TCPARAMS" ] && comparemethod
	done < "$ZONETEMP"
	# Bad luck; nothing was found.
	[ ! -f "$ZONETEMP" ] && echo '	'The search term revealed no time zones.
fi

# Cleaning up.
rm -f "$ZONETEMP"
if [ -f "$ZONETEMP-$TIMESTAMP" ] || [ -d "$ZONETEMP-$TIMESTAMP" ] || [ -h "$ZONETEMP-$TIMESTAMP" ]; then
	mv "$ZONETEMP-$TIMESTAMP" "$ZONETEMP"
fi
}

for arg in "$@"; do
	case "$arg" in 
		-h|--help)
		echo
		echo wclock - Retrieve world times based on a search term.
		echo
		echo SYNTAX:
		echo wclock [-t\|--there DATETIME -b] SEARCH [-b\|--break SEARCH] ...
		echo wclock [-l\|--local DATETIME -b] SEARCH [-b\|--break SEARCH] ...
		echo
		echo QUERY MODE:
		echo wclock -q\|--query [DIRECTORY]
		echo
		echo OPTIONS:
		echo -q\|--query - With DIRECTORY, display defined time zones in the specified time zone directory.
		echo '	'Without DIRECTORY, display all directories under "$ZONEINFO" with time zone data.
		echo '	'Incompatible with -b.
		echo
		echo -b\|--break - Enter between search terms to retrieve multiple time zones.
		echo
		echo -t\|--there - Find your local time when it is DATETIME in SEARCH.
		echo
		echo -l\|--local - Find the time in SEARCH when it is DATETIME in your time. Like "date," the TZ
		echo '	'parameter can be used to spoof a different local time zone.
		echo
		echo SEARCH - A city or country. Available cities include the namesakes of all defined time zones,
		echo '	'as well as a selection of other areas with a population of 400,000 or more.
		echo
		echo DATETIME - A past or future date and/or time to check. wclock will add any required time
		echo '	'zone information automatically. In general, the syntax is [DAY] TIME [DAY]. DAY can be
		echo '	'a day of the week \(in English\), a full date, etc. For example,
		echo
		echo '		'wclock --there 16:00 next Thu -b washington
		echo '		'wclock --local 12:00 2021/09/26 -b india
		echo
		echo '	'See date\(1\) for more information about formatting.
		echo
		echo A man page can be found at wclock\(1\).
		echo
		exit
		;;
		-q|--query)
		QUERY=yes		
		;;
		-b|--break)
		[ -n "$city" ] && localcheckval && main
		unset city
		unset GETPARAM
		;;
		-t|--there)
		[ -n "$city" ] && localcheckval && main
		unset city
		unset HERE	
		GETPARAM=yes
		unset TCPARAMS
		unset PARAMSFIXED
		THERE=yes
		;;
		-l|--local)
		[ -n "$city" ] && localcheckval && main
		unset city
		unset THERE
		GETPARAM=yes
		unset TCPARAMS
		unset PARAMSFIXED
		HERE=yes
		;;
		*)
		# Query with another argument
		if [ "$QUERY" = "yes" ]; then
			find "$ZONEINFO"/"$SUFFIX" -type f,l | grep -i "$arg" | cut -d'/' -f6- | cut -d'/' -f2- | sort | less
			exit
		# Gather arguments for specific time checks between -t or -l and
		# any other parameter.
		elif [ "$GETPARAM" = "yes" ]; then
			if [ -z "$TCPARAMS" ]; then 
				TCPARAMS="$arg"
			else
				TCPARAMS="$TCPARAMS"\ "$arg"
			fi
		else
			# Accounting for multi-word city and country names.
			[ -n "$city" ] && city="$city"_"$arg"
			[ -z "$city" ] && city="$arg"
		fi
		;;
	esac
done
localcheckval
main
[ "$THERE" != "yes" ] || [ "$NOECHO" != "yes" ] && echo
